<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<script>
  
  function bubbleSort(array) {
    let temp;
    for (let i = 0;i<array.length-1;i++) {  // 0 1 2 3
      for (let j = 0;j<array.length-1-i;j++) {  // 0 1 2 3, 0 1 2, 0 1, 0
        if (array[j] > array[j + 1]) { 
          temp = array[j]; 
          array[j] = array[j + 1];
          array[j + 1] = temp;
        }
      }
      console.log(`${i+1}회전: ${array}`);
      if(!temp){
        break;
      }
    }
    return array;
  };

  console.log(bubbleSort([5,4,3,2,1]));
  console.log(bubbleSort([5,1,7,4,6,3,2,8]));

  // 버블 정렬은 최악의 경우에 O(n^2)의 시간 복잡도를 가진다. 왜냐하면 각 자리를 찾기 위해서 n번의 순회를 해야하며 n번의 회전 동안에 요소의 개수만큼 또 순회를 해야하기 때문이다. 그러나 이미 정렬이 되어있는 경우에는 한 번의 순회로 정렬 여부를 알 수 있다. 즉, 시간복잡도가 O(n)이다.

  // 버블 정렬은 in place 알고리즘이기 때문에 메모리가 절약된다는 장점이 있다. 여기서 "in place"라는 것은 자료를 정렬할 때 추가적인 메모리 공간이 필요한 것이 아니고 데이터가 저장된 그 공간 내에서 정렬을 한다는 뜻이다.

  // 버블 정렬의 가장 큰 단점은 자료의 개수가 많아질수록 성능이 매우 떨어진다는 점이다. 왜냐면 최악의 경우 O(n^2)이 소요되기 때문이다. 만약 데이터가 위 이미지처럼 5개밖에 없다면 최대 25번 순회를 해야하지만 데이터가 1,000개라면 1,000,000번이나 순회를 해야한다.


</script>
<body>
  
</body>
</html>